# Go Channel

- **通道**：通道是可以让一个 goroutine 发送特定值到另一个 goroutine 的通信机制。
- **元素类型**：每一个通道是一个具体类型的导管，叫做通道的**元素类型**。一个有 int 类型元素的通道写为 `chan int`。

## 创建通道

使用内置的 `make` 函数来创建一个通道：

```go
ch := make(chan int)
```

1. **复制**：当复制或者作为参数传递到一个函数时，复制的是引用，这样调用者和被调用者都引用同一份数据结构。
2. **零值**：和其他引用类型一样，通道的零值是 `nil`。

### 无缓冲通道和缓冲通道

使用简单的 `make` 调用创建的通道叫 **无缓冲（unbuffered）通道**，但 `make` 还可以接受第二个可选参数，一个表示通道容量的整数。如果容量为 0，`make` 创建一个**无缓冲通道**：

```go
ch = make(chan int)     // 无缓冲通道
ch = make(chan int, 0)  // 无缓冲通道
ch = make(chan int, 3)  // 容量为 3 的缓冲通道
```

#### 无缓冲通道

- 无缓冲通道上的发送操作将会阻塞，直到另一个 goroutine 在对应的通道上执行接收操作，这时值传送完成，两个 goroutine 都可以继续执行。
- 相反，如果接收操作先执行，接收方 goroutine 将阻塞，直到另一个 goroutine 在同一个通道上发送一个值。

使用无缓冲通道进行的通信导致发送和接收 goroutine 同步化。因此，无缓冲通道也成为**同步通道**。当一个值在无缓冲通道上传递时，接收值后发送方 goroutine 才被再次唤醒。

#### 缓冲通道

缓冲通道有一个元素队列，队列的最大长度在创建的时候通过 make 的容量参数来设置。

```go
ch = make(chan string, 3)
```

缓冲通道上的发送操作在队列的尾部插入一个元素，接收操作从队列的的头部移除一个元素。

- 如果通道满了，发送操作会阻塞所在的 goroutine 直到另一个 goroutine 对它进行接收操作来留出可用的空间。
- 如果通道是空的，执行接受操作的 goroutine 阻塞，直到另一个 goroutine 在通道上发送数据。

---

- 使用内置的 `cap` 函数可以获取通道缓冲区的容量。
- 使用内置的 `len` 函数可以获取当前通道内的元素个数。

无缓冲通道提供强同步保障，因为每一次发送都需要和一次对应的接收同步；对于缓冲通道，这些操作则是解耦的。如果我们知道要发送的值数量的上限，通常会创建一个容量是使用上限的缓冲通道，在接收第一个值前就完成所有的发送。在内存无法提供缓冲容量的情况下，可能导致程序死锁。

## 通道的操作

### 发送和接收操作

通道有两个主要操作：**发送**（send）和**接收**（receive），两者统称为**通信**。

```go
ch <- x  // 发送语句
x = <-ch // 赋值语句中的接收表达式
<-ch     // 接收语句，丢弃结果
```

### 关闭操作

通道支持第三个操作：**关闭**（close），它设置一个标志位来指示值当前已经发送完毕，这个通道后面没有值了。

- 关闭后的发送操作将导致宕机。
- 在一个已经关闭的通道上进行接收操作，将获取所有已经发送的值，直到通道为空；这时任何接收操作会立即完成，同时获取到一个通道元素类型对应的零值。

调用内置的 `close` 函数来关闭通道：

```go
close(ch)
```

### 遍历通道

使用 `range` 遍历通道必须要关闭通道。如果不关闭，那么 `range` 函数就不会结束。

```go
func main() {
    queue := make(chan string, 2)
    queue <- "one"
    queue <- "two"
    close(queue)

    for elem := range queue {
        fmt.Println(elem)
    }
}
```

### 使用 select 多路复用

`select` 语句的通用形式如下：

```go
select {
case <-ch1:
    // ...
case x := <-ch2:
    // ...use x...
case ch3 <- y:
    // ...
default:
    // ...
}
```

像 `switch` 语句一样，它有一系列的情况和一个可选的默认分支。每一个情况指定一次通信（在一些通道上进行发送或接收操作）和关联的一段代码块。

`select` 一直等待，直到一次通信来告知有一些情况可以执行。然后，它进行这次通信，执行此情况所对应的语句；其他的通信将不会发生。对于没有对应情况的 `select`，`select{}` 将永远等待。

有时候我们试图在一个通道上发送或接收，但是不想在通道没有准备好的情况下被阻塞——非阻塞通信。这使用 `select` 语句也可以做到。`select` 可以有一个默认情况，它用来指定没有其他的通信发生时可以立即执行的动作。

对于 `select` 语句中的情况，如果其通道是 nil，它将永远不会被选择。

